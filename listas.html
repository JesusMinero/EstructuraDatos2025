<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Listas Ligadas Simples</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                        },
                        // Color espec√≠fico para Listas (azul/p√∫rpura)
                        listas: {
                            50: '#eff6ff',
                            500: '#3b82f6', 
                            600: '#2563eb',
                            700: '#1e40af',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .gradient-listas {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }
        .listas-visualization {
            display: flex;
            align-items: center;
            height: 100%;
            overflow-x: auto;
            padding: 10px;
        }
        .listas-item {
            width: 80px;
            padding: 10px;
            margin: 0 5px;
            background-color: #eff6ff;
            border: 2px solid #3b82f6;
            text-align: center;
            font-weight: bold;
            color: #1e40af;
            border-radius: 4px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            position: relative;
        }
        .listas-item:not(:last-child)::after {
            content: "‚Üí";
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            color: #3b82f6;
            font-weight: normal;
        }
        .listas-head {
            border-color: #ef4444; /* Rojo para el inicio (P) */
            background-color: #fee2e2;
            color: #b91c1c;
        }
        .listas-ref {
            border-color: #f59e0b; /* Amarillo para referencia */
            background-color: #fffbeb;
            color: #b45309;
        }
        .listas-target {
            border-color: #0d9488; /* Teal para nodo a eliminar/insertar */
            background-color: #ccfbf1;
            color: #0f766e;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">

    <header class="gradient-listas text-white">
        <div class="container mx-auto px-4 py-8">
            <a href="index.html" class="text-sm opacity-90 hover:opacity-100 transition duration-300">
                <i class="fas fa-arrow-left mr-2"></i> Volver a Simuladores
            </a>
            <h1 class="text-4xl md:text-5xl font-bold mt-4 mb-2 flex items-center">
                <i class="fas fa-link text-white text-3xl mr-4"></i> Simulador de Listas Ligadas Simples
            </h1>
            <p class="text-xl opacity-90">Visualiza la manipulaci√≥n de nodos en listas enlazadas.</p>
        </div>
    </header>

    <main class="container mx-auto px-4 py-12">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <div class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg h-full">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 border-b pb-3 border-gray-200">Operaciones de la Lista üíª</h2>
                
                <div class="mb-4">
                    <label for="valorDato" class="block text-sm font-medium text-gray-700 mb-2">Dato (DATO)</label>
                    <input type="number" id="valorDato" placeholder="Valor del nuevo nodo (X)" class="w-full border border-gray-300 p-3 rounded-lg focus:ring-listas-500 focus:border-listas-500" value="50">
                </div>
                <div class="mb-6">
                    <label for="valorReferencia" class="block text-sm font-medium text-gray-700 mb-2">Referencia (REF)</label>
                    <input type="number" id="valorReferencia" placeholder="Nodo de referencia (Y)" class="w-full border border-gray-300 p-3 rounded-lg focus:ring-listas-500 focus:border-listas-500">
                </div>

                <div class="space-y-2">
                    <h3 class="text-lg font-semibold border-b pb-1 text-listas-700">Inserci√≥n</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="btnInsertarInicio" class="bg-listas-600 hover:bg-listas-700 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-arrow-left mr-1"></i> Inserta Inicio
                        </button>
                        <button id="btnInsertarFinal" class="bg-listas-600 hover:bg-listas-700 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-arrow-right mr-1"></i> Inserta Final
                        </button>
                        <button id="btnInsertaAntesX" class="bg-listas-700 hover:bg-listas-800 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-undo mr-1"></i> Inserta Antes REF
                        </button>
                        <button id="btnInsertaDespuesX" class="bg-listas-700 hover:bg-listas-800 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-redo mr-1"></i> Inserta Despu√©s REF
                        </button>
                    </div>

                    <h3 class="text-lg font-semibold border-b pb-1 pt-3 text-red-700">Eliminaci√≥n</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="btnEliminarInicio" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-trash-alt mr-1"></i> Elimina Inicio
                        </button>
                        <button id="btnEliminarFinal" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-trash-alt mr-1"></i> Elimina Final
                        </button>
                        <button id="btnEliminaAntesX" class="bg-red-700 hover:bg-red-800 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-cut mr-1"></i> Elimina Antes REF
                        </button>
                        <button id="btnEliminaDespuesX" class="bg-red-700 hover:bg-red-800 text-white font-semibold py-2 rounded-lg text-xs">
                            <i class="fas fa-cut mr-1"></i> Elimina Despu√©s REF
                        </button>
                        <button id="btnEliminarNodoX" class="col-span-2 bg-red-800 hover:bg-red-900 text-white font-semibold py-2 rounded-lg text-sm">
                            <i class="fas fa-times-circle mr-2"></i> Eliminar Nodo X (DATO)
                        </button>
                    </div>
                    
                    <h3 class="text-lg font-semibold border-b pb-1 pt-3 text-gray-700">Utilidades</h3>
                    <button id="btnBuscarX" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-2 rounded-lg transition duration-300 shadow-md">
                        <i class="fas fa-search mr-2"></i> Buscar X (DATO)
                    </button>
                    <button id="btnRecorrido" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 rounded-lg transition duration-300 shadow-md">
                        <i class="fas fa-list-ol mr-2"></i> Mostrar Recorrido
                    </button>
                    <button id="btnClear" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 rounded-lg transition duration-300 shadow-md">
                        <i class="fas fa-broom mr-2"></i> Vaciar Lista
                    </button>
                </div>

                <div id="resultado" class="mt-6 p-4 rounded-lg bg-blue-50 border border-blue-200 text-sm text-blue-700 font-medium hidden">
                    Resultado de la Operaci√≥n...
                </div>
            </div>

            <div class="lg:col-span-2 space-y-8">
                
                <div class="bg-white p-6 rounded-xl shadow-lg h-56">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3 border-gray-200">Visualizaci√≥n de la Lista üìä</h2>
                    <div id="visualizacion" class="h-3/4 border-2 border-gray-300 rounded-lg p-4 bg-gray-50 listas-visualization">
                        <div id="listaVaciaMsg" class="text-gray-500 text-lg">Lista vac√≠a (P = NULL)</div>
                    </div>
                    <div class="flex justify-start text-sm mt-2">
                        <p class="text-red-500 font-bold">P (INICIO) ‚Üí</p>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3 border-gray-200">Pseudoc√≥digo del Algoritmo üìú</h2>
                    <pre id="pseudocodigo" class="bg-gray-800 text-green-300 p-4 rounded-lg overflow-x-auto text-sm mb-4">
Presiona un bot√≥n para ver el pseudoc√≥digo correspondiente a la operaci√≥n.
                    </pre>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3 border-gray-200">C√≥digo de Implementaci√≥n en C\# üíª</h2>
                    <pre id="codigoCSharp" class="bg-gray-800 text-blue-300 p-4 rounded-lg overflow-x-auto text-sm">
Presiona un bot√≥n para ver la implementaci√≥n del m√©todo en C#.
                    </pre>
                </div>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white py-6 mt-12">
        <div class="container mx-auto px-4 text-center text-gray-400">
            <p>&copy; 2023 Simulador de Listas. Estructuras de Datos Lineales.</p>
        </div>
    </footer>

    <script>
        // --- Clase Nodo (Basada en tu PPT) ---
        class Nodo {
            constructor(info) {
                this.INFO = info;
                this.LIGA = null;
            }
        }

        // --- Clase Lista (Implementaci√≥n con Lista Ligada Simple) ---
        class Lista {
            constructor() {
                this.P = null; // Puntero al primer nodo
                this.size = 0;
            }

            vacia() {
                return this.P === null;
            }

            // =======================================================
            // 1. INSERCI√ìN
            // =======================================================
            insertarInicio(dato) {
                const Q = new Nodo(dato); 
                Q.LIGA = this.P;
                this.P = Q;
                this.size++;
            }

            insertarFinal(dato) {
                const Q = new Nodo(dato);
                if (this.vacia()) {
                    this.P = Q;
                } else {
                    let T = this.P;
                    while (T.LIGA !== null) {
                        T = T.LIGA;
                    }
                    T.LIGA = Q;
                }
                this.size++;
            }

            insertarAntesX(dato, refX) {
                if (this.vacia()) return false;
                
                let Q = this.P;
                let T = null; // T es el nodo anterior a Q
                let encontrado = false;
                
                // Recorrido hasta encontrar REF o llegar al final
                while (Q !== null) {
                    if (Q.INFO === refX) {
                        encontrado = true;
                        break;
                    }
                    T = Q; 
                    Q = Q.LIGA;
                }

                if (!encontrado) return false;

                const X = new Nodo(dato); // CREAR(X)
                
                if (T === null) { // Caso 1: Insertar Antes del Primer Nodo (Q es P)
                    X.LIGA = this.P;
                    this.P = X;
                } else { // Caso 2: Insertar en medio (T es el anterior de Q)
                    T.LIGA = X;
                    X.LIGA = Q;
                }
                this.size++;
                return true;
            }

            insertarDespuesX(dato, refX) {
                if (this.vacia()) return false;

                let Q = this.P; // Q es el nodo de referencia REF

                // Buscar REF
                while (Q !== null && Q.INFO !== refX) {
                    Q = Q.LIGA;
                }

                if (Q === null) return false; // REF no encontrado

                const T = new Nodo(dato); // CREAR(T)
                
                T.LIGA = Q.LIGA; // T^.LIGA = Q^.LIGA
                Q.LIGA = T;      // Q^.LIGA = T
                
                this.size++;
                return true;
            }

            // =======================================================
            // 2. ELIMINACI√ìN
            // =======================================================
            eliminarInicio() {
                if (this.vacia()) return false;
                
                this.P = this.P.LIGA; // P=Q^.LIGA
                this.size--;
                return true; 
            }

            eliminarFinal() {
                if (this.vacia()) return false;
                
                if (this.P.LIGA === null) { // Solo hay un nodo
                    this.P = null;
                    this.size--;
                    return true;
                }

                let Q = this.P;
                let T = null; // T es el anterior (pen√∫ltimo)

                while (Q.LIGA !== null) {
                    T = Q; 
                    Q = Q.LIGA;
                }
                
                T.LIGA = null; // T^.LIGA=NILL
                this.size--;
                return true;
            }

            eliminarNodoX(datoX) {
                if (this.vacia()) return false;
                
                let Q = this.P;
                let T = null; // T es el anterior a Q

                while (Q !== null && Q.INFO !== datoX) {
                    T = Q;
                    Q = Q.LIGA;
                }
                
                if (Q === null) return false; // No encontrado

                if (T === null) { // Es el primer nodo (P=Q)
                    this.P = Q.LIGA; 
                } else { // T es el anterior de Q
                    T.LIGA = Q.LIGA; 
                }
                this.size--;
                return true;
            }

            eliminarAntesX(refX) {
                if (this.vacia() || this.P.INFO === refX) return false; // No se puede eliminar antes del primero
                
                let Q = this.P; // Nodo de Referencia REF
                let T = null; // Nodo Anterior a REF (el que se quiere eliminar)
                let R = null; // Nodo Anterior a T (el que se queda enlazado)

                // Buscar (T) y (R) tal que R -> T -> Q(REF)
                while (Q !== null && Q.INFO !== refX) {
                    R = T; // R guarda la posici√≥n de T anterior
                    T = Q; // T guarda la posici√≥n de Q anterior
                    Q = Q.LIGA;
                }

                if (Q === null) return false; // REF no encontrado

                if (T === this.P) { // Si el nodo a eliminar (T) es el primero (P)
                    this.P = Q; // P salta al nodo REF (Q)
                } else { // Si T es un nodo intermedio
                    R.LIGA = Q; // R salta a Q (eliminando a T)
                }

                this.size--;
                return true;
            }
            
            eliminarDespuesX(refX) {
                if (this.vacia()) return false;
                
                let Q = this.P; // Nodo de Referencia REF

                // Buscar REF
                while (Q !== null && Q.INFO !== refX) {
                    Q = Q.LIGA;
                }

                if (Q === null || Q.LIGA === null) return false; // REF no encontrado o es el √∫ltimo

                // Q es REF, Q.LIGA es el nodo a eliminar (W), Q.LIGA.LIGA es el siguiente de W
                const W = Q.LIGA;
                Q.LIGA = W.LIGA; // Q^.LIGA = Q^.LIGA^.LIGA
                
                this.size--;
                return true;
            }
            
            // =======================================================
            // 3. OTRAS
            // =======================================================
            buscar(datoX) {
                let Q = this.P;
                while (Q !== null) {
                    if (Q.INFO === datoX) {
                        return Q.INFO;
                    }
                    Q = Q.LIGA;
                }
                return false;
            }
            
            mostrar() {
                let reco = this.P;
                let elementos = [];
                while (reco !== null) {
                    elementos.push(reco.INFO);
                    reco = reco.LIGA;
                }
                return elementos.join(' ‚Üí ');
            }
            
            clear() {
                this.P = null;
                this.size = 0;
            }
        }

        const lista = new Lista();
        const valorDatoInput = document.getElementById('valorDato');
        const valorReferenciaInput = document.getElementById('valorReferencia');
        const visualizacionDiv = document.getElementById('visualizacion');
        const resultadoDiv = document.getElementById('resultado');
        const pseudocodigoDiv = document.getElementById('pseudocodigo');
        const codigoCSharpDiv = document.getElementById('codigoCSharp');

        // --- Funciones de Interfaz ---

        function updateVisualizacion(refValue = null, targetValue = null) {
            visualizacionDiv.innerHTML = ''; 
            let reco = lista.P;
            let index = 0;
            
            if (lista.vacia()) {
                visualizacionDiv.innerHTML = '<div id="listaVaciaMsg" class="text-gray-500 text-lg">Lista vac√≠a (P = NULL)</div>';
                return;
            }

            while (reco !== null) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'listas-item';
                
                if (index === 0) {
                    itemDiv.classList.add('listas-head');
                }
                if (refValue !== null && reco.INFO == refValue) {
                    itemDiv.classList.add('listas-ref');
                }
                if (targetValue !== null && reco.INFO == targetValue && reco.INFO != refValue) {
                    itemDiv.classList.add('listas-target');
                }

                itemDiv.textContent = reco.INFO;
                visualizacionDiv.appendChild(itemDiv);
                reco = reco.LIGA;
                index++;
            }
        }

        function showResult(message, isError = false) {
            resultadoDiv.textContent = message;
            resultadoDiv.classList.remove('hidden');
            if (isError) {
                resultadoDiv.className = 'mt-6 p-4 rounded-lg bg-red-50 border border-red-200 text-sm text-red-700 font-medium';
            } else {
                resultadoDiv.className = 'mt-6 p-4 rounded-lg bg-listas-50 border border-listas-200 text-sm text-listas-700 font-medium';
            }
            setTimeout(() => resultadoDiv.classList.add('hidden'), 5000);
        }

        function showPseudocodigo(codigo) {
            pseudocodigoDiv.textContent = codigo;
        }
        
        function showCSharpCode(codigo) { 
            codigoCSharpDiv.textContent = codigo;
        }

        // --- Pseudoc√≥digos y C# ---
        
        // --- Inserci√≥n ---
        const pseudocodigoInsertarInicio = `
// Operaci√≥n: Insertar un nodo al inicio de la lista
1. CREAR(Q)
2. Q^.INFORMACION = DATO
3. Q^.LIGA = P
4. P = Q
        `;
        const csharpInsertarInicio = `
// M√©todo para insertar un nodo al inicio de la lista
public void InsertaInicio(int dato)
{
    Nodo Q = new Nodo();
    Q.INFO = dato;
    Q.LIGA = P;
    P = Q;
}
        `;
        
        const pseudocodigoInsertarFinal = `
// Operaci√≥n: Insertar un nodo al final de la lista
1. CREAR(Q)
2. Q^.INFORMACION = DATO, Q^.LIGA = NILL
3. SI (P = NILL)
4.     P = Q
5. SINO
6.     T = P
7.     REPETIR MIENTRAS T^.LIGA <> NILL
8.         T = T^.LIGA
9.     FIN_CICLO
10.    T^.LIGA = Q
11. FIN_SI
        `;
        const csharpInsertarFinal = `
// M√©todo para insertar un nodo al final de la lista
public void InsertaFinal(int dato)
{
    Nodo Q = new Nodo();
    Q.INFO = dato;
    Q.LIGA = null;
    
    if (P == null)
    {
        P = Q;
    }
    else
    {
        Nodo T = P;
        while (T.LIGA != null)
        {
            T = T.LIGA;
        }
        T.LIGA = Q;
    }
}
        `;
        
        const pseudocodigoInsertaAntesX = `
// Operaci√≥n: Inserta un nodo antes de un dato de REFERENCIA (Q)
1. Q=P, T=NILL, BAND=TRUE
2. REPETIR MIENTRAS (Q^.INFO <> REF) Y (Q^.LIGA <> NILL)
3.     T=Q, Q=Q^.LIGA
4. FIN_CICLO
5. SI Q^.INFO = REF
6.     CREAR(X), X^.INFO = DATO
7.     SI P = Q // Insertar antes del primero
8.         X^.LIGA = P, P = X
9.     SI_NO // Insertar en medio
10.        T^.LIGA = X, X^.LIGA = Q
11.    FIN_CONDICIONAL
12. FIN_CONDICIONAL
        `;
        const csharpInsertaAntesX = `
// M√©todo para insertar antes de un nodo de referencia (REF)
public bool InsertaAntesX(int dato, int REF)
{
    Nodo Q = P;
    Nodo T = null; 

    while (Q != null && Q.INFO != REF)
    {
        T = Q;
        Q = Q.LIGA;
    }

    if (Q == null) return false; // REF no encontrado

    Nodo X = new Nodo();
    X.INFO = dato;

    if (T == null) // Q es el primer nodo (P)
    {
        X.LIGA = P;
        P = X;
    }
    else // T es el anterior de Q
    {
        T.LIGA = X;
        X.LIGA = Q;
    }
    return true;
}
        `;

        const pseudocodigoInsertaDespuesX = `
// Operaci√≥n: Inserta un nodo despu√©s de un dato de REFERENCIA (Q)
1. Q=P, BAND=TRUE
2. REPETIR MIENTRAS (Q^.INFO <> REF) Y (Q^.LIGA <> NILL)
3.     Q=Q^.LIGA
4. FIN_DEL_CICLO
5. SI Q^.INFO = REF
6.     CREA(T), T^.INFO = DATO
7.     T^.LIGA = Q^.LIGA
8.     Q^.LIGA = T
9. FIN_CONDICIONAL
        `;
        const csharpInsertaDespuesX = `
// M√©todo para insertar despu√©s de un nodo de referencia (REF)
public bool InsertaDespuesX(int dato, int REF)
{
    Nodo Q = P;

    while (Q != null && Q.INFO != REF)
    {
        Q = Q.LIGA;
    }

    if (Q == null) return false; // REF no encontrado

    Nodo T = new Nodo();
    T.INFO = dato;
    
    T.LIGA = Q.LIGA; // Enlaza T al resto de la lista
    Q.LIGA = T;      // Enlaza Q al nuevo nodo T
    
    return true;
}
        `;

        // --- Eliminaci√≥n ---
        const pseudocodigoEliminarInicio = `
// Operaci√≥n: Eliminar el primer nodo
1. Q = P
2. SI Q^.LIGA <> NILL
3.     P = Q^.LIGA
4. SI_NO
5.     P = NILL
6. FIN_CONDICIONAL
7. QUITA(Q)
        `;
        const csharpEliminarInicio = `
// M√©todo para eliminar el primer nodo
public bool EliminaPrimer()
{
    if (P == null) return false;
    
    if (P.LIGA != null)
    {
        P = P.LIGA;
    }
    else
    {
        P = null;
    }
    return true; 
}
        `;

        const pseudocodigoEliminarFinal = `
// Operaci√≥n: Eliminar el √∫ltimo nodo
1. SI P^.LIGA = NILL
2.     QUITA(P), P = NILL
3. SI_NO
4.     Q = P, T = NILL
5.     REPETIR MIENTRAS Q^.LIGA <> NILL
6.         T = Q, Q = Q^.LIGA
7.     FIN_CICLO
8.     T^.LIGA = NILL
9.     QUITA(Q)
10. FIN_CONDICIONAL
        `;
        const csharpEliminarFinal = `
// M√©todo para eliminar el √∫ltimo nodo
public bool EliminaUltimo()
{
    if (P == null) return false;

    if (P.LIGA == null) 
    {
        P = null;
        return true;
    }

    Nodo Q = P;
    Nodo T = null; 

    while (Q.LIGA != null)
    {
        T = Q;
        Q = Q.LIGA;
    }

    T.LIGA = null;
    return true;
}
        `;
        
        const pseudocodigoEliminarNodoX = `
// Operaci√≥n: Eliminar un nodo con Informaci√≥n X
1. Q=P, T=NILL
2. REPETIR MIENTRAS (Q^.INFO <> X) Y (Q^.LIGA <> NILL)
3.     T=Q, Q=Q^.LIGA
4. FIN_CICLO
5. SI Q^.INFO <> X
6.     ESCRIBIR ‚ÄúELEMENTO NO ENCONTRADO‚Äù
7. SI_NO
8.     SI P = Q // Es el primer nodo
9.         P = Q^.LIGA
10.    SI_NO // Es un nodo intermedio/final
11.        T^.LIGA = Q^.LIGA
12.    FIN_CONDICIONAL
13.    QUITA(Q)
14. FIN_CONDICIONAL
        `;
        const csharpEliminarNodoX = `
// M√©todo para eliminar un nodo con informaci√≥n X
public bool EliminaNodoX(int X)
{
    Nodo Q = P;
    Nodo T = null;

    while (Q != null && Q.INFO != X)
    {
        T = Q;
        Q = Q.LIGA;
    }

    if (Q == null) return false;

    if (T == null) // Es el primer nodo
    {
        P = Q.LIGA;
    }
    else 
    {
        T.LIGA = Q.LIGA;
    }
    return true; 
}
        `;
        
        const pseudocodigoEliminaAntesX = `
// Operaci√≥n: Eliminar el nodo ANTES de REFERENCIA (Q)
1. SI (P = NILL) O (P^.INFO = REF) // No se puede antes del 1ro
2.     RETORNAR ERROR
3. Q=P, T=NILL, R=NILL
4. REPETIR MIENTRAS Q^.INFO <> REF
5.     R=T, T=Q, Q=Q^.LIGA // R apunta a T, T apunta a Q(REF)
6. FIN_CICLO
7. SI (Q = NILL) RETORNAR ERROR // REF no encontrado
8. SI (T = P) // El nodo a eliminar (T) es el primero
9.     P = Q // P salta al nodo REF
10. SI_NO // T es intermedio (R existe)
11.    R^.LIGA = Q // R salta a Q (eliminando T)
12. FIN_CONDICIONAL
13. QUITA(T)
        `;
        const csharpEliminaAntesX = `
// M√©todo para eliminar el nodo anterior a REF
public bool EliminaAntesX(int REF)
{
    if (P == null || P.INFO == REF) return false;

    Nodo Q = P; // Nodo de Referencia
    Nodo T = null; // Nodo a Eliminar
    Nodo R = null; // Nodo Anterior al de Eliminar

    while (Q != null && Q.INFO != REF)
    {
        R = T;
        T = Q;
        Q = Q.LIGA;
    }

    if (Q == null) return false; // REF no encontrado

    if (T == P) // T (a eliminar) es el primer nodo
    {
        P = Q; // P salta a REF (Q)
    }
    else // T es intermedio
    {
        R.LIGA = Q; // R salta a Q
    }
    return true;
}
        `;
        
        const pseudocodigoEliminaDespuesX = `
// Operaci√≥n: Eliminar el nodo DESPU√âS de REFERENCIA (Q)
1. SI (P = NILL) RETORNAR ERROR
2. Q=P, BAND=TRUE
3. REPETIR MIENTRAS (Q^.INFO <> REF) Y (Q^.LIGA <> NILL)
4.     Q=Q^.LIGA
5. FIN_CICLO
6. SI (Q^.INFO <> REF) O (Q^.LIGA = NILL) RETORNAR ERROR // REF no encontrado o es el √∫ltimo
7. W = Q^.LIGA // Nodo a eliminar
8. Q^.LIGA = W^.LIGA // Q salta al siguiente de W
9. QUITA(W)
        `;
        const csharpEliminaDespuesX = `
// M√©todo para eliminar el nodo posterior a REF
public bool EliminaDespuesX(int REF)
{
    if (P == null) return false;

    Nodo Q = P; // Nodo de Referencia

    while (Q != null && Q.INFO != REF)
    {
        Q = Q.LIGA;
    }

    if (Q == null || Q.LIGA == null) return false; // REF no encontrado o es el √∫ltimo

    Nodo W = Q.LIGA; // Nodo a eliminar
    Q.LIGA = W.LIGA; // Q salta a W.LIGA
    
    return true;
}
        `;
        
        // --- Utilidades ---
        const pseudocodigoBuscarX = `
// Operaci√≥n: B√∫squeda de un Elemento
1. Q=P
2. REPETIR MIENTRAS Q <> NILL
3.     SI Q^.INFORMACION = X
4.         ESCRIBIR ‚Äú EL ELEMENTO ESTA EN LA LISTA‚Äù
5.         RETORNAR
6.     Q=Q^.LIGA
7. FIN_CICLO
8. ESCRIBIR ‚ÄúELEMENTO NO FUE ENCONTRADO‚Äù
        `;
        const csharpBuscarX = `
// M√©todo para buscar un elemento
public bool Busqueda(int X)
{
    Nodo Q = P;
    while (Q != null)
    {
        if (Q.INFO == X)
        {
            return true;
        }
        Q = Q.LIGA;
    }
    return false;
}
        `;
        
        const pseudocodigoRecorrido = `
// Operaci√≥n: Recorrido / Mostrar Lista
1. Q = P
2. REPETIR MIENTRAS Q <> NILL
3.     ESCRIBIR Q^.INFORMACION
4.     Q = Q^.LIGA
5. FIN_CICLO
        `;
        const csharpRecorrido = `
// M√©todo para mostrar la lista
public void MostrarLista()
{
    Nodo Q = P;
    Console.WriteLine("Elementos de la lista:");
    while(Q != null)
    {
        Console.WriteLine(Q.INFO);
        Q = Q.LIGA;
    }
}
        `;
        
        const pseudocodigoVaciar = `
// Operaci√≥n: Vaciar Lista
1. P = NILL
2. RETORNAR Exitoso
        `;
        const csharpVaciar = `
// M√©todo para vaciar (limpiar) la lista
public void Vaciar() 
{
    P = null; 
}
        `;
        
        // --- Event Listeners ---
        
        document.getElementById('btnInsertarInicio').addEventListener('click', () => {
            const valor = parseInt(valorDatoInput.value);
            if (isNaN(valor)) { showResult('¬°Error! Ingrese un DATO num√©rico v√°lido.', true); return; }
            lista.insertarInicio(valor);
            updateVisualizacion();
            showPseudocodigo(pseudocodigoInsertarInicio);
            showCSharpCode(csharpInsertarInicio);
            showResult(`DATO ${valor} insertado al INICIO.`);
        });

        document.getElementById('btnInsertarFinal').addEventListener('click', () => {
            const valor = parseInt(valorDatoInput.value);
            if (isNaN(valor)) { showResult('¬°Error! Ingrese un DATO num√©rico v√°lido.', true); return; }
            lista.insertarFinal(valor);
            updateVisualizacion();
            showPseudocodigo(pseudocodigoInsertarFinal);
            showCSharpCode(csharpInsertarFinal);
            showResult(`DATO ${valor} insertado al FINAL.`);
        });
        
        document.getElementById('btnInsertaAntesX').addEventListener('click', () => {
            const dato = parseInt(valorDatoInput.value);
            const refX = parseInt(valorReferenciaInput.value);
            if (isNaN(dato) || isNaN(refX)) { showResult('¬°Error! Ingrese DATO y REFERENCIA num√©ricos v√°lidos.', true); return; }
            
            const exito = lista.insertarAntesX(dato, refX);
            updateVisualizacion(refX);
            showPseudocodigo(pseudocodigoInsertaAntesX);
            showCSharpCode(csharpInsertaAntesX);
            
            if (exito) {
                showResult(`DATO ${dato} insertado ANTES de la REFERENCIA ${refX}.`);
            } else {
                showResult(`¬°Error! La REFERENCIA ${refX} no fue encontrada o es el primer nodo.`, true);
            }
        });

        document.getElementById('btnInsertaDespuesX').addEventListener('click', () => {
            const dato = parseInt(valorDatoInput.value);
            const refX = parseInt(valorReferenciaInput.value);
            if (isNaN(dato) || isNaN(refX)) { showResult('¬°Error! Ingrese DATO y REFERENCIA num√©ricos v√°lidos.', true); return; }
            
            const exito = lista.insertarDespuesX(dato, refX);
            updateVisualizacion(refX);
            showPseudocodigo(pseudocodigoInsertaDespuesX);
            showCSharpCode(csharpInsertaDespuesX);
            
            if (exito) {
                showResult(`DATO ${dato} insertado DESPU√âS de la REFERENCIA ${refX}.`);
            } else {
                showResult(`¬°Error! La REFERENCIA ${refX} no fue encontrada.`, true);
            }
        });

        // --- Eventos de Eliminaci√≥n ---

        document.getElementById('btnEliminarInicio').addEventListener('click', () => {
            const exito = lista.eliminarInicio();
            if (exito) {
                updateVisualizacion();
                showPseudocodigo(pseudocodigoEliminarInicio);
                showCSharpCode(csharpEliminarInicio);
                showResult(`Primer nodo eliminado exitosamente.`);
            } else {
                showResult('¬°Error! La lista est√° vac√≠a.', true);
            }
        });

        document.getElementById('btnEliminarFinal').addEventListener('click', () => {
            const exito = lista.eliminarFinal();
            if (exito) {
                updateVisualizacion();
                showPseudocodigo(pseudocodigoEliminarFinal);
                showCSharpCode(csharpEliminarFinal);
                showResult(`√öltimo nodo eliminado exitosamente.`);
            } else {
                showResult('¬°Error! La lista est√° vac√≠a.', true);
            }
        });

        document.getElementById('btnEliminarNodoX').addEventListener('click', () => {
            const valorX = parseInt(valorDatoInput.value);
            if (isNaN(valorX)) { showResult('¬°Error! Ingrese el DATO (X) a eliminar.', true); return; }

            const exito = lista.eliminarNodoX(valorX);
            updateVisualizacion();
            showPseudocodigo(pseudocodigoEliminarNodoX);
            showCSharpCode(csharpEliminarNodoX);

            if (exito) {
                showResult(`Nodo con DATO ${valorX} eliminado exitosamente.`);
            } else {
                showResult(`¬°Error! Nodo con DATO ${valorX} no encontrado o lista vac√≠a.`, true);
            }
        });
        
        document.getElementById('btnEliminaAntesX').addEventListener('click', () => {
            const refX = parseInt(valorReferenciaInput.value);
            if (isNaN(refX)) { showResult('¬°Error! Ingrese la REFERENCIA num√©rica v√°lida.', true); return; }

            const exito = lista.eliminarAntesX(refX);
            updateVisualizacion(refX);
            showPseudocodigo(pseudocodigoEliminaAntesX);
            showCSharpCode(csharpEliminaAntesX);

            if (exito) {
                showResult(`Nodo ANTES de la REFERENCIA ${refX} eliminado exitosamente.`);
            } else {
                showResult(`¬°Error! La REFERENCIA ${refX} no fue encontrada o es el primer nodo.`, true);
            }
        });

        document.getElementById('btnEliminaDespuesX').addEventListener('click', () => {
            const refX = parseInt(valorReferenciaInput.value);
            if (isNaN(refX)) { showResult('¬°Error! Ingrese la REFERENCIA num√©rica v√°lida.', true); return; }

            const exito = lista.eliminarDespuesX(refX);
            updateVisualizacion(refX);
            showPseudocodigo(pseudocodigoEliminaDespuesX);
            showCSharpCode(csharpEliminaDespuesX);

            if (exito) {
                showResult(`Nodo DESPU√âS de la REFERENCIA ${refX} eliminado exitosamente.`);
            } else {
                showResult(`¬°Error! La REFERENCIA ${refX} no fue encontrada o es el √∫ltimo nodo.`, true);
            }
        });

        // --- Eventos de Utilidades ---

        document.getElementById('btnBuscarX').addEventListener('click', () => {
            const valorX = parseInt(valorDatoInput.value);
            if (isNaN(valorX)) { showResult('¬°Error! Ingrese el DATO (X) a buscar.', true); return; }

            const encontrado = lista.buscar(valorX);
            updateVisualizacion(encontrado ? valorX : null);
            showPseudocodigo(pseudocodigoBuscarX);
            showCSharpCode(csharpBuscarX);

            if (encontrado) {
                showResult(`DATO ${valorX} ENCONTRADO en la lista.`);
            } else {
                showResult(`DATO ${valorX} NO ENCONTRADO en la lista.`, true);
            }
            setTimeout(() => updateVisualizacion(null), 3000); // Limpia la referencia visual despu√©s de 3s
        });

        document.getElementById('btnRecorrido').addEventListener('click', () => {
            const recorrido = lista.mostrar();
            showPseudocodigo(pseudocodigoRecorrido);
            showCSharpCode(csharpRecorrido);
            if (recorrido) {
                showResult(`Recorrido: P ‚Üí ${recorrido} ‚Üí NULL`);
            } else {
                showResult('La lista est√° vac√≠a.', true);
            }
            updateVisualizacion();
        });
        
        document.getElementById('btnClear').addEventListener('click', () => {
            lista.clear();
            updateVisualizacion();
            showPseudocodigo(pseudocodigoVaciar);
            showCSharpCode(csharpVaciar);
            showResult('La Lista ha sido VACIADA (P = NULL).');
        });

        // Inicializar la visualizaci√≥n
        updateVisualizacion();
    </script>
</body>
</html>